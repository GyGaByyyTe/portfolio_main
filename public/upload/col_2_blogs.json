{"_id":{"$oid":"5ac65d83483550146cfa58b9"},"title":"asd","date":{"$date":"2018-04-05T00:00:00.000Z"},"body":"asd","__v":0}
{"_id":{"$oid":"5ac89ba0cd1f5003a07fc0f2"},"title":"test2","date":{"$date":"2018-04-07T00:00:00.000Z"},"body":"Привет, тестовая запись!","__v":0}
{"_id":{"$oid":"5ac89c02cd1f5003a07fc0f3"},"title":"Vue.js для сомневающихся. Все, что нужно знать","date":{"$date":"2018-04-05T00:00:00.000Z"},"body":"В данной статье речь пойдет о замечательном фронтенд фреймворке Vue.js. Как вы видите, статья называется «Vue.js для сомневающихся», и, если вы до сих пор не могли решиться попробовать Vue.js на практике, то надеюсь, что после прочтения вы все-таки на это решитесь.\n\nФреймворки разрабатываются для того, чтобы упростить нам жизнь и освободить от написания однотипного кода. Но, по мере того как кодовая база некоторых фреймворков сильно разрастается, они начинают привносить свою долю сложности в проект. Из-за этого при планировании разработки мы должны учитывать два фактора:\n\nсложность нашего приложения\nсложность фреймворка, который мы используем\n\nНемного абстрагируемся и назовём это внутренней сложностью (то есть сложностью, от которой мы не можем избавиться при разработке) и сложностью инструмента, с помощью которого мы достигаем той или иной цели. Естественно манипулировать мы можем только сложностью инструмента.","__v":0}
{"_id":{"$oid":"5ac89cd2cd1f5003a07fc0f4"},"title":"Десять вопросов о Node.js, на которые вы не сможете ответить","date":{"$date":"2018-04-06T00:00:00.000Z"},"body":"В этом году, на конференции Forward.js, посвящённой JavaScript, я выступал с докладом «You don’t know Node». Во время выступления я задал аудитории несколько вопросов о Node, и большинство присутствующих не смогли ответить на многие из них. А ведь мой доклад слушали технические специалисты. Никаких подсчётов я не производил, но выглядело всё именно так, да и несколько слушателей, которые подошли ко мне после выступления, это подтвердили.\n\nПроблема, которая заставила меня сделать то выступление, заключается в том, что, по-моему, система обучения Node выстроена неправильно. Большинство учебных материалов сосредоточено на пакетах Node, но не на самой платформе. Часто этих пакеты служат обёртками для модулей Node (вроде http или stream). Как результат, тот, кто не знает Node и сталкивается с проблемой, источником которой может оказаться не некий пакет, а платформа, оказывается в крайне невыгодном положении.\n\nЯ выбрал несколько вопросов и ответов с той конференции и включил их в эту статью. Сами вопросы представлены в заголовках разделов статьи. Попытайтесь, прочтя вопрос, не читать дальше, а сначала мысленно на него ответить. Если вы найдёте ошибку в моих ответах — пожалуйста дайте мне знать.\n\nВопрос №1. Что такое стек вызовов и является ли он частью движка V8?\n\nСтек вызовов (Call Stack) определённо является частью V8. Это — структура данных, которую V8 использует для отслеживания вызовов функций. Каждый раз, когда мы вызываем функцию, V8 помещает ссылку на эту функцию в стек вызовов, а когда из этой функции вызываются другие функции, продолжает делать то же самое со ссылками на них. Кроме того, в стек попадают и функции, которые вызывают сами себя рекурсивно.\n\nКогда, при вложенных вызовах функций, функция завершает выполнение, V8 извлекает ссылку на функцию из верхней части стека вызовов и подставляет возвращённое ей значение туда, куда требует логика программы.\n\nПочему это важно понимать при работе с Node? Дело в том, что на один процесс Node приходится только один стек вызовов. Если стек будет полон, процесс окажется нагружен какой-то работой. Об этом стоит помнить.\n\nВопрос №2. Что такое цикл событий? Является ли он частью движка V8?\n\nЦикл событий реализован в библиотеке libuv. Он не является частью V8.\n\nЦикл событий — это сущность, которая обрабатывает внешние события и преобразует их в вызовы коллбэков. Это — довольно сложно устроенный цикл, который берёт события из очереди событий и помещает их коллбэки в стек вызовов.\n\nЕсли вы впервые слышите о цикле событий, вышеприведённые рассуждения могут оказаться не особенно вразумительными. Цикл событий является частью гораздо более общей картины:\n\n\nЦикл событий. Скриншот из моего курса на Pluralsight, посвящённого продвинутому изучению Node.js\n\nДля того, чтобы понять сущность цикла событий, полезно знать о том, в какой среде он работает. Нужно понимать роль V8, знать об API Node, и о том, как работает очередь событий, код, связанный с которыми, выполняется в V8.\n\nAPI Node — это функции, вроде setTimeout или fs.readFile. Они не являются частью JavaScript. Это — просто функции, доступ к которым даёт нам Node.\n\nЦикл событий находится в центре всего этого (конечно, на самом деле, всё это устроено сложнее) и играет роль организатора. Когда стек вызовов V8 пуст, цикл событий может принять решение о том, что следует выполнять дальше.\n\nВопрос №3. Что будет делать Node, когда стек вызовов и очереди цикла событий окажутся пустыми?\n\nОтвет прост: Node просто завершит работу.\n\nКогда вы запускаете приложение, Node автоматически запускает цикл событий, а когда цикл событий простаивает, когда ему нечего делать, процесс завершает работу.\n\nДля того, чтобы процесс Node не завершался, нужно поместить что-нибудь в очередь событий. Например, когда вы запускаете таймер или HTTP-сервер, вы сообщаете циклу событий о том, что ему нужно продолжать работу и следить за этими событиями.\n\nВопрос №4. Помимо движка V8 и библиотеки libuv, какие ещё внешние зависимости есть у Node?","__v":0}
{"_id":{"$oid":"5ac92dd582951f2180b1cfec"},"title":"На сегодня последняя запись","date":{"$date":"2018-04-07T00:00:00.000Z"},"body":"23:44","__v":0}
{"_id":{"$oid":"5aca632aed92411e98557487"},"title":"Запись за 8е число","date":{"$date":"2018-04-08T00:00:00.000Z"},"body":"ПРоверка сайта после установки аутентификации","__v":0}
